<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dreamy Pink Christmas Tree</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Parisienne&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #020102; 
      font-family: 'Great Vibes', 'Parisienne', cursive;
    }

    #canvas-container {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: crosshair;
      z-index: 1;
    }

    .ui-overlay {
      position: fixed;
      left: 50%;
      bottom: 30px;
      transform: translateX(-50%);
      text-align: center;
      color: #fff;
      pointer-events: none;
      z-index: 10;
      font-family: system-ui, sans-serif;
    }

    .btn {
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 24px;
      margin: 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 182, 193, 0.5);
      background: radial-gradient(circle at top, rgba(255, 192, 203, 0.25), rgba(0, 0, 0, 0.8));
      color: #fff0f5;
      font-size: 12px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      box-shadow: 0 0 15px rgba(255, 182, 193, 0.3);
      transition: all 0.4s ease;
      cursor: pointer;
    }

    .btn:hover {
      background: radial-gradient(circle at top, rgba(255, 182, 193, 0.5), rgba(0, 0, 0, 0.9));
      transform: translateY(-2px);
      box-shadow: 0 0 25px rgba(255, 182, 193, 0.6);
    }

    .mc-text {
      position: fixed;
      left: 5%;
      top: 50%;
      transform: translateY(-50%);
      color: #ffe6f2;
      font-family: 'Great Vibes', cursive;
      font-size: 50px; 
      font-weight: 400;
      text-shadow: 0 0 15px rgba(255, 182, 193, 0.6), 0 0 30px rgba(255, 192, 203, 0.4);
      pointer-events: none;
      opacity: 0;
      animation: textFadeIn 3s 0.5s forwards ease-out;
      z-index: 5;
      line-height: 1.2;
      text-align: left;
    }

    .mc-sub {
      display: block;
      font-family: 'Parisienne', cursive;
      font-size: 22px;
      opacity: 0.9;
      margin-top: 8px;
      color: #fff;
      letter-spacing: 0.05em;
      text-shadow: 0 0 8px rgba(255, 182, 193, 0.6);
    }

    @keyframes textFadeIn {
      from { opacity: 0; transform: translate(-20px, -50%); filter: blur(8px); }
      to { opacity: 1; transform: translate(0, -50%); filter: blur(0); }
    }

    #music-control {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 20;
      font-size: 24px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.3s;
      color: #ffc0cb;
      pointer-events: auto;
    }
    #music-control:hover { opacity: 1; text-shadow: 0 0 10px #ffc0cb; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <audio id="bgm" loop>
    <source src="https://music.163.com/song/media/outer/url?id=185763.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <div id="music-control" title="Play/Pause Music">üéµ</div>

  <div class="mc-text">
    Merry Christmas
    <span class="mc-sub">Make a wish tonight</span>
  </div>

  <div class="ui-overlay">
    <button class="btn" id="btn-reset">
      üíÉ <span>MY LUCKY CHARM</span> üíÉ
    </button>
    <button class="btn" id="btn-chaos">
      üéÅ <span>A GIFT FOR YOU</span> üéÅ
    </button>
  </div>

  <!-- Three.js CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    const bgm = document.getElementById('bgm');
    const musicBtn = document.getElementById('music-control');
    let isPlaying = false;
    musicBtn.addEventListener('click', () => {
      if (isPlaying) {
        bgm.pause();
        musicBtn.style.opacity = 0.5;
      } else {
        bgm.play();
        musicBtn.style.opacity = 1;
      }
      isPlaying = !isPlaying;
    });

    function createBrightTexture(baseColor) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');

      const gradient = ctx.createRadialGradient(
        size / 2, size / 2, 0,
        size / 2, size / 2, size / 2
      );
      
      gradient.addColorStop(0.0, 'rgba(255, 255, 255, 0.9)'); 
      gradient.addColorStop(0.15, baseColor); 
      gradient.addColorStop(1.0, 'rgba(0, 0, 0, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();

      return new THREE.CanvasTexture(canvas);
    }

    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020102);
    scene.fog = new THREE.FogExp2(0x020102, 0.012);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 32);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5)); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const palePinkTex = createBrightTexture('rgba(255, 182, 193, 0.6)'); 
    const whiteTex = createBrightTexture('rgba(255, 255, 255, 0.7)');
    
    const heartPinkTex = (() => {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      const g = ctx.createRadialGradient(size/2,size/2,0, size/2,size/2,size/2);
      g.addColorStop(0.0, 'rgba(255, 182, 193, 0.8)'); 
      g.addColorStop(0.5, 'rgba(255, 228, 225, 0.3)'); 
      g.addColorStop(1.0, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(size/2,size/2,size/2,0,Math.PI*2); ctx.fill();
      return new THREE.CanvasTexture(canvas);
    })();

    const group = new THREE.Group();
    scene.add(group);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(0, 0);
    
    const hitGeo = new THREE.ConeGeometry(12, 30, 16);
    const hitMat = new THREE.MeshBasicMaterial({ visible: false });
    const hitMesh = new THREE.Mesh(hitGeo, hitMat);
    hitMesh.position.y = 0;
    group.add(hitMesh);


    // =============== 1. Á≤íÂ≠êÁ≥ªÁªü (Ê†ë / ËàûËÄÖ) ===============
    const TREE_COUNT = 25000; 
    const TREE_HEIGHT = 26;
    const TREE_RADIUS = 10;
    
    const t_pos = new Float32Array(TREE_COUNT * 3);
    const t_start = new Float32Array(TREE_COUNT * 3);
    const t_target_tree = new Float32Array(TREE_COUNT * 3); 
    const t_target_dancer = new Float32Array(TREE_COUNT * 3); // ËàûËÄÖÁõÆÊ†á
    const t_sizes = new Float32Array(TREE_COUNT);
    const t_interact = new Float32Array(TREE_COUNT * 3); 
    const t_part_id = new Float32Array(TREE_COUNT); // Ë∫´‰ΩìÈÉ®‰ΩçÊ†áËÆ∞

    // Ê†ëÂΩ¢ÊÄÅ
    for(let i=0; i<TREE_COUNT; i++){
      const t = Math.random();
      const y = -TREE_HEIGHT/2 + TREE_HEIGHT * t;
      const rBase = (1-t) * TREE_RADIUS;
      
      let x, z;
      if(Math.random() < 0.75) { 
        const turns = 8.0;
        const angle = t * Math.PI * 2 * turns;
        const r = rBase * (0.9 + Math.random()*0.2);
        x = r * Math.cos(angle);
        z = r * Math.sin(angle);
      } else {
        const angle = Math.random() * Math.PI * 2;
        const r = rBase * Math.random();
        x = r * Math.cos(angle);
        z = r * Math.sin(angle);
      }
      if(t > 0.92) { x *= 0.3; z *= 0.3; }

      const i3 = i*3;
      t_target_tree[i3] = x; 
      t_target_tree[i3+1] = y; 
      t_target_tree[i3+2] = z;
      
      t_start[i3] = (Math.random()-0.5)*100;
      t_start[i3+1] = (Math.random()-0.5)*100;
      t_start[i3+2] = (Math.random()-0.5)*100;

      t_pos[i3] = t_start[i3]; 
      t_pos[i3+1] = t_start[i3+1]; 
      t_pos[i3+2] = t_start[i3+2];
      
      t_sizes[i] = 0.1 + Math.random() * 0.2; 
    }

    // ËàûËÄÖÂΩ¢ÊÄÅÁîüÊàê helper
    // 0:Head, 1:Body, 2:LArm, 3:RArm, 4:LLeg, 5:RLeg
    function assignDancerPart(i) {
      const ratio = i / TREE_COUNT;
      if(ratio < 0.15) return 0; // Head
      if(ratio < 0.45) return 1; // Body
      if(ratio < 0.58) return 2; // LArm
      if(ratio < 0.71) return 3; // RArm
      if(ratio < 0.85) return 4; // LLeg
      return 5; // RLeg
    }

    // ÁîüÊàêËàûËÄÖÈùôÊÄÅÂü∫Á°Ä‰ΩçÁΩÆ (T-pose Á±ª‰ºº)
    for(let i=0; i<TREE_COUNT; i++){
      const part = assignDancerPart(i);
      t_part_id[i] = part;
      
      let x=0, y=0, z=0;
      const r = Math.random();
      const th = Math.random() * Math.PI * 2;

      if(part === 0) { // Head (Sphere)
        const rad = 2.0 * Math.cbrt(r);
        const phi = Math.acos(2*Math.random()-1);
        x = rad * Math.sin(phi) * Math.cos(th);
        y = 14 + rad * Math.sin(phi) * Math.sin(th);
        z = rad * Math.cos(phi);
      } else if(part === 1) { // Body (Cylinder)
        const rad = 2.5 * Math.sqrt(r);
        const h = Math.random() * 10; // 4 to 14
        x = rad * Math.cos(th);
        y = 4 + h;
        z = rad * Math.sin(th);
      } else if(part === 2) { // LArm (Cylinder ish)
        // Shoulder at (2.5, 12, 0) -> Length 7
        const len = Math.random() * 7;
        const rad = 0.8 * Math.sqrt(r);
        x = -2.5 - len; 
        y = 12 + rad * Math.cos(th);
        z = rad * Math.sin(th);
      } else if(part === 3) { // RArm
        const len = Math.random() * 7;
        const rad = 0.8 * Math.sqrt(r);
        x = 2.5 + len;
        y = 12 + rad * Math.cos(th);
        z = rad * Math.sin(th);
      } else if(part === 4) { // LLeg
        // Hip at (-1.5, 4, 0) -> Length 9
        const len = Math.random() * 9;
        const rad = 1.0 * Math.sqrt(r);
        x = -1.5 + rad * Math.cos(th);
        y = 4 - len;
        z = rad * Math.sin(th);
      } else { // RLeg
        const len = Math.random() * 9;
        const rad = 1.0 * Math.sqrt(r);
        x = 1.5 + rad * Math.cos(th);
        y = 4 - len;
        z = rad * Math.sin(th);
      }

      const i3 = i*3;
      t_target_dancer[i3] = x;
      t_target_dancer[i3+1] = y - 6; // Êï¥‰Ωì‰∏ãÁßªÂ±Ö‰∏≠
      t_target_dancer[i3+2] = z;
    }

    const treeGeo = new THREE.BufferGeometry();
    treeGeo.setAttribute('position', new THREE.BufferAttribute(t_pos, 3));
    treeGeo.setAttribute('size', new THREE.BufferAttribute(t_sizes, 1));

    const particleVs = `
      attribute float size;
      varying float vAlpha;
      void main() {
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        float zDist = max(-mvPosition.z, 1.0);
        gl_PointSize = size * (380.0 / zDist); 
        vAlpha = 0.8 + 0.05 * sin(position.y * 5.0); 
      }
    `;
    const particleFs = `
      uniform vec3 uColor;
      uniform sampler2D uTexture;
      varying float vAlpha;
      void main() {
        vec4 tex = texture2D(uTexture, gl_PointCoord);
        if(tex.a < 0.02) discard; 
        gl_FragColor = vec4(uColor, tex.a * vAlpha);
      }
    `;

    const treeMat = new THREE.ShaderMaterial({
      uniforms: {
        uColor: { value: new THREE.Color(0xFFB6C1) }, 
        uTexture: { value: palePinkTex }
      },
      vertexShader: particleVs,
      fragmentShader: particleFs,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const treePoints = new THREE.Points(treeGeo, treeMat);
    group.add(treePoints);


    // =============== 2. Áà±ÂøÉ ===============
    const HEART_COUNT = 1000; 
    const h_pos = new Float32Array(HEART_COUNT * 3);
    const h_start = new Float32Array(HEART_COUNT * 3);
    const h_target = new Float32Array(HEART_COUNT * 3);
    const h_sizes = new Float32Array(HEART_COUNT);
    const h_local = new Float32Array(HEART_COUNT * 3); 

    for(let i=0; i<HEART_COUNT; i++){
      const t = Math.random() * Math.PI * 2;
      const r = 0.2 + Math.random() * 0.8; 
      let x = 16 * Math.pow(Math.sin(t), 3);
      let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      let z = (Math.random()-0.5) * 5;

      const scale = 0.09; 
      const offsetY = TREE_HEIGHT/2 + 2.0;
      x *= scale * r;
      y = y * scale * r + offsetY;
      z *= scale * r;

      const i3 = i*3;
      h_local[i3] = x; h_local[i3+1] = y - offsetY; h_local[i3+2] = z;
      h_target[i3] = x; h_target[i3+1] = y; h_target[i3+2] = z;
      
      h_start[i3] = (Math.random()-0.5)*40; h_start[i3+1] = (Math.random()-0.5)*40 + offsetY; h_start[i3+2] = (Math.random()-0.5)*40;
      h_pos[i3] = h_start[i3]; h_pos[i3+1] = h_start[i3+1]; h_pos[i3+2] = h_start[i3+2];
      h_sizes[i] = 0.15 + Math.random() * 0.25;
    }
    const heartGeo = new THREE.BufferGeometry();
    heartGeo.setAttribute('position', new THREE.BufferAttribute(h_pos, 3));
    heartGeo.setAttribute('size', new THREE.BufferAttribute(h_sizes, 1));
    const heartMat = new THREE.ShaderMaterial({
      uniforms: {
        uColor: { value: new THREE.Color(0xffc1cc) }, 
        uTexture: { value: heartPinkTex } 
      },
      vertexShader: particleVs,
      fragmentShader: particleFs,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const heartPoints = new THREE.Points(heartGeo, heartMat);
    group.add(heartPoints);

    const heartGlow = new THREE.PointLight(0xffc0cb, 0, 30); 
    heartGlow.position.set(0, TREE_HEIGHT/2 + 2.0, 0);
    group.add(heartGlow);


    // =============== 3. Á©∫Èó¥Á≤íÂ≠ê (Â¢ûÂä† + Êâ©Êï£) ===============
    const SPACE_COUNT = 20000; // ÁøªÂÄç
    const s_pos = new Float32Array(SPACE_COUNT * 3);
    const s_vel = new Float32Array(SPACE_COUNT * 3);
    const s_sizes = new Float32Array(SPACE_COUNT);

    for(let i=0; i<SPACE_COUNT; i++){
      const i3 = i*3;
      // Êâ©Â§ßËåÉÂõ¥
      s_pos[i3] = (Math.random()-0.5) * 220;
      s_pos[i3+1] = (Math.random()-0.5) * 180;
      s_pos[i3+2] = (Math.random()-0.5) * 220;

      s_vel[i3] = (Math.random()-0.5) * 0.06;
      s_vel[i3+1] = (Math.random()-0.5) * 0.06;
      s_vel[i3+2] = (Math.random()-0.5) * 0.06;

      s_sizes[i] = 0.15 + Math.random() * 0.3; 
    }
    const spaceGeo = new THREE.BufferGeometry();
    spaceGeo.setAttribute('position', new THREE.BufferAttribute(s_pos, 3));
    spaceGeo.setAttribute('size', new THREE.BufferAttribute(s_sizes, 1));
    const spaceMat = new THREE.ShaderMaterial({
      uniforms: {
        uColor: { value: new THREE.Color(0xffffff) }, 
        uTexture: { value: whiteTex }
      },
      vertexShader: particleVs,
      fragmentShader: particleFs,
      transparent: true,
      opacity: 0.9, // ÊèêÈ´ò‰∫ÆÂ∫¶
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const spacePoints = new THREE.Points(spaceGeo, spaceMat);
    scene.add(spacePoints);


    // =============== 4. Âú∞Èù¢ (ËøûË¥ØËµ∑‰ºè) ===============
    const GROUND_COUNT = 35000; 
    const g_pos = new Float32Array(GROUND_COUNT * 3);
    const g_sizes = new Float32Array(GROUND_COUNT);
    
    // ‰ΩøÁî®Ëû∫ÊóãÁ∫øÁîüÊàêÔºåÂ§©ÁÑ∂ËøûË¥Ø
    for(let i=0; i<GROUND_COUNT; i++){
      // ÈòøÂü∫Á±≥Âæ∑Ëû∫Êóã r = a + b*theta
      const t = i / GROUND_COUNT;
      const theta = t * 100 * Math.PI * 2; // ÂúàÊï∞
      const r = 2.0 + t * 98.0; // ÂçäÂæÑÊâ©Êï£
      
      // Âä†ÂÖ•ÂæÑÂêëÈöèÊú∫ÂÅèÁßªÔºåÂ°´Ë°•Ëû∫Êóã‰πãÈó¥ÁöÑÁ©∫Èöô
      const rJitter = r + (Math.random() - 0.5) * 1.5;
      
      const x = rJitter * Math.cos(theta);
      const z = rJitter * Math.sin(theta);
      const y = -TREE_HEIGHT/2 - 2.0; 
      
      const i3 = i*3;
      g_pos[i3] = x; g_pos[i3+1] = y; g_pos[i3+2] = z;
      g_sizes[i] = 0.1 + t * 0.2; 
    }

    const groundGeo = new THREE.BufferGeometry();
    groundGeo.setAttribute('position', new THREE.BufferAttribute(g_pos, 3));
    groundGeo.setAttribute('size', new THREE.BufferAttribute(g_sizes, 1));

    const groundMat = new THREE.ShaderMaterial({
      uniforms: {
        uColor: { value: new THREE.Color(0xffffff) }, 
        uTexture: { value: whiteTex },
        uTime: { value: 0 }
      },
      vertexShader: `
        attribute float size;
        uniform float uTime;
        varying float vAlpha;
        void main() {
          vec3 pos = position;
          float dist = length(pos.xz);
          // Ê≥¢Êµ™Ëµ∑‰ºè
          pos.y += sin(dist * 0.2 - uTime * 1.5) * 0.7 + sin(pos.x * 0.2 + uTime) * 0.3;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;
          float zDist = max(-mvPosition.z, 1.0);
          gl_PointSize = size * (450.0 / zDist);
          vAlpha = 0.85 - smoothstep(0.0, 120.0, dist); 
        }
      `,
      fragmentShader: particleFs,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const groundPoints = new THREE.Points(groundGeo, groundMat);
    group.add(groundPoints);


    // =============== Âä®Áîª & ‰∫§‰∫í ===============
    let startTime = performance.now();
    const DURATION = 5000;
    let dreamMode = false;
    let currentMode = 'TREE'; 
    let danceTimer = 0;

    function easeOutCubic(x) {
      return 1 - Math.pow(1 - x, 3);
    }

    let isMouseActive = false;
    window.addEventListener('mousemove', e => {
      isMouseActive = true;
      const x = (e.clientX / window.innerWidth) * 2 - 1;
      const y = -(e.clientY / window.innerHeight) * 2 + 1;
      mouse.set(x, y);
    });

    document.getElementById('btn-reset').addEventListener('click', () => {
      startTime = performance.now();
      currentMode = 'DANCER_MORPH';
      heartPoints.visible = false; 
      heartGlow.visible = false;
    });

    document.getElementById('btn-chaos').addEventListener('click', () => {
      dreamMode = !dreamMode;
      const btn = document.getElementById('btn-chaos');
      btn.querySelector('span').innerText = dreamMode ? "RETURN..." : "A GIFT FOR YOU";
      if(!dreamMode && currentMode === 'TREE') startTime = performance.now();
    });
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });


    function animate() {
      requestAnimationFrame(animate);
      
      const now = performance.now();
      const time = now * 0.001;
      groundMat.uniforms.uTime.value = time;

      let morph = 0;
      
      if (currentMode === 'TREE') {
        let progress = (now - startTime) / DURATION;
        if(progress > 1) progress = 1;
        if(dreamMode) progress = Math.max(progress - 0.03, 0);
        morph = easeOutCubic(progress);
        heartPoints.visible = true;
        heartGlow.visible = true;

      } else if (currentMode === 'DANCER_MORPH') {
        let progress = (now - startTime) / 3000; 
        if (progress >= 1) {
          progress = 1;
          currentMode = 'DANCER_STAY';
          danceTimer = now;
        }
        morph = easeOutCubic(progress); 

      } else if (currentMode === 'DANCER_STAY') {
        morph = 1; 
        if (now - danceTimer > 8000) { // Ë∑≥8Áßí
          currentMode = 'TREE_RETURN';
          startTime = now; 
        }

      } else if (currentMode === 'TREE_RETURN') {
        let progress = (now - startTime) / 4000;
        if (progress >= 1) {
          progress = 1;
          currentMode = 'TREE';
          startTime = now; 
        }
        morph = 1 - easeOutCubic(progress); 
      }

      raycaster.setFromCamera(mouse, camera);
      let hoverPoint = null;
      const intersects = raycaster.intersectObject(hitMesh);
      if (intersects.length > 0) hoverPoint = intersects[0].point;

      // Êõ¥Êñ∞Ê†ë/ËàûËÄÖ
      const tp = treeGeo.attributes.position.array;
      for(let i=0; i<TREE_COUNT; i++){
        const i3 = i*3;
        
        // 1. ËÆ°ÁÆóÁõÆÊ†áÊèíÂÄº‰ΩçÁΩÆ (ÈùôÊÄÅ)
        let tx, ty, tz;
        
        if (currentMode === 'TREE') {
          tx = t_start[i3]   + (t_target_tree[i3]   - t_start[i3])   * morph;
          ty = t_start[i3+1] + (t_target_tree[i3+1] - t_start[i3+1]) * morph;
          tz = t_start[i3+2] + (t_target_tree[i3+2] - t_start[i3+2]) * morph;
        } else {
          // DANCER Áõ∏ÂÖ≥Áä∂ÊÄÅ
          let m = morph;
          if (currentMode === 'DANCER_STAY') m = 1;
          
          const treeX = t_target_tree[i3];
          const treeY = t_target_tree[i3+1];
          const treeZ = t_target_tree[i3+2];
          
          const dancerX = t_target_dancer[i3];
          const dancerY = t_target_dancer[i3+1];
          const dancerZ = t_target_dancer[i3+2];

          tx = treeX + (dancerX - treeX) * m;
          ty = treeY + (dancerY - treeY) * m;
          tz = treeZ + (dancerZ - treeZ) * m;
        }

        // 2. ËàûËÄÖÂä®ÊÄÅÂè†Âä† (Âè™Âú®ÂèòË∫´ÂÆåÊàêÂêé)
        if (currentMode === 'DANCER_STAY' || (currentMode === 'DANCER_MORPH' && morph > 0.5)) {
           const pid = t_part_id[i];
           // ÁÆÄÂçïÁöÑÈ™®È™ºÂä®ÁîªÈÄªËæë (Ê≠£Âº¶Ê≥¢È©±Âä®)
           // 0:Head, 1:Body, 2:LArm, 3:RArm, 4:LLeg, 5:RLeg
           const danceStr = (currentMode === 'DANCER_MORPH') ? (morph - 0.5)*2 : 1.0;
           
           if(pid === 0) { // Head bob
             ty += Math.sin(time * 4) * 0.5 * danceStr;
             tx += Math.cos(time * 2) * 0.3 * danceStr;
           } else if(pid === 1) { // Body bounce
             ty += Math.sin(time * 4) * 0.5 * danceStr;
           } else if(pid === 2) { // LArm wave
             ty += Math.sin(time * 4 + 1) * 2.0 * danceStr;
             tx += Math.cos(time * 4) * 1.0 * danceStr;
           } else if(pid === 3) { // RArm wave
             ty += Math.sin(time * 4 + 2) * 2.0 * danceStr;
             tx -= Math.cos(time * 4) * 1.0 * danceStr;
           } else if(pid === 4) { // LLeg step
             ty += Math.max(0, Math.sin(time * 4)) * 1.5 * danceStr;
           } else if(pid === 5) { // RLeg step
             ty += Math.max(0, Math.sin(time * 4 + 3.14)) * 1.5 * danceStr;
           }
        }

        // 3. ‰∫§‰∫í & Ê¢¶Â¢É
        if(dreamMode && currentMode === 'TREE') {
           tx += Math.sin(time + i) * 2.0;
           ty += Math.cos(time + i*0.5) * 2.0;
           tz += Math.sin(time + i*0.3) * 2.0;
        }

        let dx = 0, dy = 0, dz = 0;
        if(hoverPoint && currentMode === 'TREE') {
           const distSq = (tx - hoverPoint.x)**2 + (ty - hoverPoint.y)**2 + (tz - hoverPoint.z)**2;
           const radius = 6.0; 
           if(distSq < radius * radius) {
             const dist = Math.sqrt(distSq);
             const safeDist = Math.max(dist, 0.01);
             const force = (radius - dist) / radius; 
             const factor = 5.0 * force; 
             dx = (tx - hoverPoint.x) / safeDist * factor;
             dy = (ty - hoverPoint.y) / safeDist * factor;
             dz = (tz - hoverPoint.z) / safeDist * factor;
           }
        }

        let ox = t_interact[i3]; let oy = t_interact[i3+1]; let oz = t_interact[i3+2];
        ox += (dx - ox) * 0.1; oy += (dy - oy) * 0.1; oz += (dz - oz) * 0.1;
        t_interact[i3] = ox; t_interact[i3+1] = oy; t_interact[i3+2] = oz;
        tp[i3] = tx + ox; tp[i3+1] = ty + oy; tp[i3+2] = tz + oz;
      }
      treeGeo.attributes.position.needsUpdate = true;

      // Áà±ÂøÉ
      const hp = heartGeo.attributes.position.array;
      heartGlow.intensity = (currentMode === 'TREE' ? morph : 0) * 1.0; 
      const heartFloatY = Math.sin(time * 1.5) * 0.3;
      const heartScale = 1.0 + Math.sin(time * 3.0) * 0.05; 

      for(let i=0; i<HEART_COUNT; i++){
        const i3 = i*3;
        if (currentMode !== 'TREE') {
           hp[i3] = h_start[i3]; hp[i3+1] = h_start[i3+1]; hp[i3+2] = h_start[i3+2];
        } else {
           const mx = h_start[i3]   + (h_target[i3]   - h_start[i3])   * morph;
           const my = h_start[i3+1] + (h_target[i3+1] - h_start[i3+1]) * morph;
           const mz = h_start[i3+2] + (h_target[i3+2] - h_start[i3+2]) * morph;

           if(morph > 0.8 && !dreamMode) {
              const cy = TREE_HEIGHT/2 + 2.0;
              let lx = h_local[i3]; let ly = h_local[i3+1]; let lz = h_local[i3+2];
              lx *= heartScale; ly *= heartScale; lz *= heartScale;
              const rot = time * 0.5;
              const rx = lx * Math.cos(rot) - lz * Math.sin(rot);
              const rz = lx * Math.sin(rot) + lz * Math.cos(rot);
              hp[i3] = rx; hp[i3+1] = cy + ly + heartFloatY; hp[i3+2] = rz;
           } else {
              hp[i3] = mx; hp[i3+1] = my; hp[i3+2] = mz;
           }
        }
      }
      heartGeo.attributes.position.needsUpdate = true;
      heartGlow.position.y = TREE_HEIGHT/2 + 2.0 + heartFloatY;

      // Á©∫Èó¥Á≤íÂ≠ê
      const sp = spaceGeo.attributes.position.array;
      const LIMIT = 80; 
      for(let i=0; i<SPACE_COUNT; i++){
        const i3 = i*3;
        sp[i3] += s_vel[i3]; sp[i3+1] += s_vel[i3+1]; sp[i3+2] += s_vel[i3+2];
        if(sp[i3]>LIMIT) sp[i3]=-LIMIT; if(sp[i3]<-LIMIT) sp[i3]=LIMIT;
        if(sp[i3+1]>LIMIT) sp[i3+1]=-LIMIT; if(sp[i3+1]<-LIMIT) sp[i3+1]=LIMIT;
        if(sp[i3+2]>LIMIT) sp[i3+2]=-LIMIT; if(sp[i3+2]<-LIMIT) sp[i3+2]=LIMIT;
      }
      spaceGeo.attributes.position.needsUpdate = true;

      const autoRot = time * 0.1; 
      if(isMouseActive) {
        group.rotation.y = autoRot + mouse.x * 0.3;
        group.rotation.x = mouse.y * 0.05;
      } else {
        group.rotation.y = autoRot;
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>

